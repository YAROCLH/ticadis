1.1
*Distinguiendo y justificando sistemas*

	La identificacion del sistema es el resultado de un proceso de distincion influenciado por la capacidad del observador de distinguir cosas.
	Por justificacion se entiende que el sistema identificado cumple determinados conceptos que lo caracterizan por ejemplo: finalidad, objetivo, retroalimentacion etc.


-La justificacion de un sistema 

	Objetivo:
		Un sistema se justifica cuando se le ha asignado la capacidad de tener un objetivo, pero hay que tener en cuenta que siempre el objetivo es asignado  por el observador
			-Se dice que un sistema posee un objetivo asignado externamente por un observador cuando se desconoce o no se comprende cual es su finalidad  y es dicho observador quien entiende y establece cual "podria" ser su objetivo.
			Este observador debe ser cuidadoso al asignar el objetivo ya que un observador con poca experiencia, podria comprender un sistema y su objetivo desde un limitado campo de vision o de opciones.

	Frontera:
		Las fronteras e un sistema son las que delimitan "lo que esta dentro y fuera del sistema", para saber que esta dentro y que esta afuera hay que hacer 2 preguntas
			*¿que debe controlar el sistema?
			*¿que puede controlar el sistema?
		-Esta dentro del sistema todo aquello que debe y puede controlar el sistema

		-Esta fuera todo aquello que no debe y no puede controlar el sistema y pasa a ser parte del entorno o medio externo al sistema.

		-Estara en la frontera todo aquello que debe controlar pero no puede controlar y por lo tanto debe influir para procurar hacerlo con interacciones de salida hacia el entorno que es donde se encuentran esos elementos que deben controlarse.

		-Estara en la frontera todo aquello que no debe controlar pero que si controla, en estos casos de debe evaluar si se debe dejar dentro o fuera del sistema, pues los elementos involucrados pueden ser parte de "otro sistema".


	Interacciones:
		Si "ver" el sistema es complejo, el ver las interacciones lo es mas.
		El sistema es definido por un observador o modelador. Puede que exista antes de que el modelador observe la realidad o no. En este momento, cuando se define o se identifica el sistema es cuando el modelador debe distinguir suspartes,las interacciones entre estas partes y las interacciones de las partes con el entorno.	Pero esto lo hace a un nivel abstracto, basado en los conceptos que le permiten identifiacr partes e interacciones.
		Es decir en este nivel de observacion el sistema es una concepcion mental.Nada mas.

-Interaciones entre sistemas y estructuras
		...
		...
		...


*Productos informaticos en un contexto organizacional*
	Un producto informatico alude a un conjunto de componentes de diversos tipos:
		Un software que responde a una necesidad, un hardware donde opera el software, personas que operan el software y hardware.
	Todos estos elementos, cuya mision es tratar la informacion (tomar deciciones,procesar datos,etc), y ademas son los elementos disponibles para dar forma al sistemas.
	Aqui surge el real conflicto, construir un sistema a nivel abstracto y conceptual para luego construir materialmente una estructura que sea bien recibida por la estructura de otros sistemas relacionados y con la estructura del propio entorno.
	En una empresa, el  producto informatico debe insertarse estructuralmente en la estructura de la empresa.

-La insercion estructural
	Parte del modelado es estudiar la capacidad de que el producto informatico sea aceptado admitido y asimilado por una organizacion.No es raro ecuchar de sistemas rechazados o pobremente usados por motivos que no son tecnicos sino por "feeling" al software.
	Es mision del modelador preveer esta circunstancia, por lo cual el modelado demanda una comprension organizacional muy clara tanto a nivel procesos como a nivel personas.
	Por lo tanto se debe considerar todos los componentes sistemicos en forma de funciones y tareas a cumplir y proveer, sabiendo que habra interaccion con un medio que no espera siempre "con buenos ojos" un nuevo actor organizacional(el sistema).
	Las funciones y tareas que se hayan previsto se realicen de manera abstracta(en papel), asi aparecen actores y agentes (personas) que deben entrenarse, seleccionarse o eliminarse para que el sistema funcione y que sea aceptado.
	El analista debe concebir un sistema integrado a una realidad organizacional que no debe dañar sino hacerla mejor y al mismo tiempo el diseñador se preocupa de que todo encaje con los recursos existentes.

-La de-construccion organizacional
	Todo producto informatico desde el momento en que se concibe altera la organizacion receptora. Por este motivo el analista que realiza un alaisis de situacion actual debe ser cuidadoso para no descubrir  cuando termina su estudio que la organizacion no es la misma o que asimilo cosas derivadas del estudio.
	En todo este proceso los conceptos se re-hacen producto de nuevas visiones, las concepciones del trabajo como se hace cambia conforme aparecen nuevas formas de trabajo mas automatizadas, las personas ven variar su entorno y por ende su concepcion de la organizacion y sus metodos de trabajo.Todo esto se conoce como deconstrucion, que surge porque los conceptos varian gracias al desarrollo del producto informatico desde sus faces de analisis y diseño.



-LA ULTIMA PALABRA LA TIENE EL USUARIO
	-Se dice que cualquier esfuerzo de analisar y diseñar no sirve de nada si el usuario no acepta el producto
	Hay que ser cuidadoso pues el analisis involucra pensar en las personas que trabajaran y se veran afectadas por el producto informatico. Este usuario de debe ver como una figura que "nada sabe" y ademas de manera natural precisa ser entrenado en una nueva herramienta que muchas veces no espera ni desea.
	Los usuarios pueden ser divididos en 2 tipos 
		-Los usuarios , que como tal usan el artefacto o sistema, aportando y/o recibiendo datos, pero que desconoce ni le preocupa como funciona dicho sistema.
		-Los operadores, que permiten que el sistema opere de manera normal y revisan el comportamiento del mismo a nivel de:
			-sus variables de operacion( que miden su rendimiento, tiempos de respuesta, comportamiento, etc)
			-sus variables funcionales (que miden la capacidad de atender y satisfacer los requerimientos que justifican el sistema)
			-sus variables estrategicas (que analizan la existencia del sistema dentro de los procesosestrategicos de la empresa)

		Por ultimo esta el cliente que es quien financia el desarrollo puede ser usuario, operador  o no ocupar posicion alguna.


1.2 Analisis de sistemas y formas de modelamiento
**El analisis y el diseño en los modelos de desarrollo

Dentro de la ingenieria de software existen varios paradigmas para poder llegar a la contruccion final del producto, a esa serie de procedimientos y etapas se le denomina ciclo de vida.Este ciclo consiste en la concepcion, construccion, implementacion, y aplicacion del producto.
Estos paradigmas surgidos a finales de los años 60 e inicios de los 70, tambien llamados modelos de ciclo de vida del software,  son hoy el marco de referencia mas usado para describir el proceso de desarrollo de un proyecto informatico, describen los pasos a seguir, los puntos de terminacion, los subproductos a entregar y las fases a seguir.

Lo que se persigue con estos paradigmas es que el producto o solucion sea: 
	-Comprensible, claro y bien definido en sus detalles y en el trabajo realizado.
	-Bien construido
	-Robusto, en el sentido que puede seguir operando bajo condiciones de fallo o error.
	-Mantenible, o que se pueda ajustar a cambios futuros con facilidad 

La eleccion de la forma de desarrollo tiene un efecto significativo en el exito del proyecto. El paradigma es un proceso cuya adecuacion puede conducir a que el sistema se complete rapidamente, con un costo reducido, mayor calidad  y menor riesgo. Un proceso inadecuado conduce a esfuerzos de trabajo duplicados, problemas en la programacion y problemas de gestion.

A continuacion se describen los paradigmas mas representativos.

***Cascada o Tradicional***

Es el mas comun y se puede considerar el mas basico de todos los modelos de ciclo de vida, lo cual lo convierte en base para otros modelos.
Fue originalmente documentado en el año 1970, lo que lo convierte en el paradigma de ingenieria mas antiguo.
Este modelo expone que el desarrollo de software puede verse como una secuencia simple de fases encadenadas linealmente.
	-Especificacion de requerimientos
	-Planificacion
	-Moodelamiento
	-Construccion y desarrollo
	-Soporte (mantenimiento) del software completo

Estas fases en ocasiones cambian de nombre, pueden cambiar de orden o simplemente aparecer dentro de otras.No obstante, las fases indicadas siempre estan presentes y el modelo no pierde su linealidad ni su secuencia en las etapas o fases que se desea destacar.
En cada fase de debe realizar un proceso de verificacion y validacion
	Validacion: ¿estamos construyendo correctamente el producto?
	Verificacion: ¿estamos construyendo el producto correcto?

En este paradigma se utilizan las siguientes etapas:
	a)Ingenieria y Analisis del Sistema. Debido a que el software es parte de un sistema mayor el trabajo comienza estableciendo los requisitos de todos los elementos del sistema y luego asignando algun subconjunto de estos requisitos al software.

	b)Analisis de los requisitos del software. El proceso de recopilacion de los requisitos se centra en el software. El analista debe comprender el ambito de la informacion del software, asi como la funcion del mismo, el rendimiento y las interfaces requeridas.

	c)Diseño. El diseño del se enfoca en 4 atributos distintos: El diseño de los datos, la arquitectura de software, el detalle procedimental y la caracterizacion de la interfaz. 
	El diseño traduce los requisitos en una representacion del software con la calidad requerida antes de que comience la codificacion.

	d)Prueba. Una vez que se ha generado el codigo comienza la prueba, que se centra en la logica interna del software y en las funciones esternas, realizando pruebas que aseguren que la entrada definida produce los resultados que realmente se requieren.

	e)Mantenimiento. El software sufrira cambios despues de que se entrgue al cliente. Los cambios ocurriran debidi a que se hayan encontrado errores, a que el software deba adaptarse a cambios del entorno o debido a que el cliente lo requiera.

Caracteristicas y factores de decision
	Este paradigma funciona cuando los requerimientos del problema son razonables y bien comprendidos y el riesgo de inestabilidad es bajo. Aunque ultimamente se ha cuestionado la eficiencia del modelo en cascada, algunas de las razones son las siguientes:
		-Los proyectos reales raramente siguen un orden secuencial
		-Es dificil lograr que el cliente otorgue requerimientos explicitos a alto nivel
		-Se produce un caos cuando un error grave es detectado en una etapa muy avanzada del proyecto
		-El cliente debe ser paciente y esperar a ver el resultado final del proceso.

	Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:
	Caracteristicas:
		-Cada fase empieza cuando se ha terminado la anterior
		-Para pasar a la fase posterior es necesario haber logrado los objetivos de la previa
		-Es util como control de fechas de entregas
		-Al final de cada fase el personal tecnico y los usuarios pueden revisar el progreso

	Factores de Decision
		-Todos los requerimientos son conocidos al proncipio
		-Solo se desarrolla lo que se conoce bien
		-Los usuarios lo pruebas y añaden requerimientos
		-La aplicacion se hace por fases
		-Se hace una implementacion parcial y se prueba
		-Se utiliza en sistemas de complejidad baja


***PARADIGMAS DE DESARROLLO INCREMENTALES***

En situaciones en las que los requerimientos entan bien definidos, pero segun el alcance del proyecto existe la posibilidad de que el desarrollo no sea lineal, se provee de un paradigma que esta diseñado para producir software por incrementos. Para ello limitan la funcionalidad del software para que pueda ser revisado por el cliente y que este a su vez lo refine para tenerlo listo en la siguiente etapa del proyecto.

***Paradigma incremental***

En este paradigma el desarrollo se organiza en una serie de etapas, teniendo al final de cada etapa una version funcional y usable, con funcionalidades añadidas respecto al anterior incremento.
Para cada una de estas versiones se realiza en cada incremento una revision del analisis anterior, un diseño o revision del diseño existentes, la codificacion necesaria y las pruebas de las nuevas funcionalidades. De esta forma cada version cumple uno o mas requisitos que la version anterior y el numero de requisitos por cumplir se va reduciendo.
Cada version se usa como base para la siguiente version, teniendo en cuenta la retroalimentacion recibida por el cliente.
El paradigma incremental combina elementos del paradigma de cascada, aplicandolo de forma iterativa.Aplica secuencias lineales a mode de fases.Cada secuencia produce incrementos entregables del software
Las etapas del paradigma incremental son
	-Ingenieria y Analisis del Sistema
	-Analisis de los requerimientos
	-Diseño
	-Codificacion
	-Pruebas
	-Mantenimiento

*Caracteristicas y factores de decision*
Este paradigma es particularmente util cuando el personal no esta disponible para hacer una implementacion completa para la fecha acordada con el cliente.Los incrementos de etapa temprana pueden ser ejecutados por una menor cantidad de personas.
Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:
	Caracteristicas:
		-Se desarrolla el sistema por partes, incrementandolas y juntandolas despues
		-Los errores producidos en un incremento son solucionados para el siguiente incremento
		-Se involucra mas al usuario
		-Se basa en el modelo cascada
		-Se van añadiendo funcionalidades

	Factores de decision
		-Se debe tener claro algunos de los requerimientos al principio
		-Es menos arriesgado un sistema pequeño que uno grande
		-Dificil evaluar el costo total
		-Los errores en los requisitos se detectan tarde

***Paradigma RAD(Diseño Rapido de Aplicaciones)***
Es una adaptacion a alta velocidad del paradigma en cascada, en el que se enfatiza en un ciclo de vida extremadamente corto.
Las etapas del paradigma RAD son:
	-Modelado de Gestion
		El flujo de informacion entre las funciones de gestion que se modela de modo que responda a las siguientes preguntas:
			-¿Que informacion conduce el proceso de gestion?
			-¿Que informacion se genera?
			-¿Quien la genera?
			-¿A donde va la informacion?
			-¿Quien la procesa?

	-Modelado de Datos
		El flujo de informacion definido en la fase anterior se refina como un conjunto de objetos de datos necesarios.Se definen las caracteristicas de cada uno de los objetos y las relaciones entre estos

	-Modelado de Procesos
		Los objetos de definidos en la fase anterior se transforman para lograr el flujo de informacion necesario para implementar una funcion de gestion.Las descripciones del proceso se crean para añadir, modificar, suprimir o recuperar objetos de datos.

	-Generacion de Aplicaciones
		RAD asume que en lugar de crear el software con lenguajes de programacion se usan componentes de programas ya existentes cuando es posible o se crean componentes reutilizables cuando es necesario.En todos los casos se utilizan herramientas automaticas para facilitar la construccion del software.

	-Prueba y entrega
		Como el proceso de RAD enfatiza en la reutilizacion, ya se han comprobado muchis de los componentes de los programas.Esto reduce el tiempo de pruebas.Sin embargo se deben probar todos los componentes nuevos.

*Caracteristicas y factores de decision*

Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:
	Caracteristicas
		-El desarrollo del sistema completamente funcional se da en periodos cortos
		-Se utiliza un enfoque de construccion basado en objetos reusables

	Factores de decision
		-Se requiere comprender bien los requisitos y el ambito del proyecto
		-Necesita que el cliente y el desarrollador se comprometan en las actividades necesarias para completar un sistema en tiempo corto

No es adecuado en entornos tecnologicos nuevos o entornos que requieran interoperatividad con aplicaciones existentes pues no se dejara tiempo suficiente para pruebas de integracion.



***PARADIGMAS DE DESARROLLO EVOLUTIVOS***

Se sabe de antemano que el software al igual que todos los sistemas complejos evoluciona con el tiempo. Los paradigmas evolutivos se caracterizan por desarrollar versiones cada vez mas completas del software

***Paradigma de construccion de prototipos***

Este paradigma añade al final de cada evolucion una etapa de retroalimentacion con el cliente, para evaluar el resultado. Al final de cada fase es necesario descartar el prototipo anterior y comenzar de nuevo.
El uso de este paradigma se centra en la idea de ayudar a comprender los requisitos que plantea el usuario, sobre todo si este no tiene una idea muy clara de lo que desea.Tambien puede utilizarse cuando el ingeniero de software tiene dudas acerca de la viabilidad de la solucion pensada.
La version temprana de lo que sera el producto, con una funcionalidad reducida, podra incrementarse paulatinamente a traves de refinamientos sucesivos de las especificaciones del sistema, evolucionando hasta llegar al sistema final.

Al usar este paradigma, las etapas del ciclo de vida quedan modificadas de la siguiente manera:
	-Requerimientos, Analisis de requisitos del sistema y analisis de requisitos del software
	-Diseño, desarrollo e implementacion del prototipo
	-Codificacion y test unitario, prueba del prototipo, refinamiento iterativo del prototipo y refinamiento de las especificaciones del prototipo
	-Integracion del sistema, diseño e implementacion del sistema final
	-Explotacion, operacion y mantenimiento.

Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:

	Caracteristicas:
		-Solo se desarrollan los (requerimientos)?  que se conocen bien   |-------- ??? ---------|
		-Los usuarios lo prueban y añaden requerimientos
		-La aplicacion se hace por fases
		-Se hace una implementacion parcial y se prueba
		-Una vez identificados todos los requisitos mediante el prototipo, se construye el producto de ingenieria

	Factores de decision:
		-Todos los requerimientos no son conocidos al principio
		-Se utiliza en sistemas complejos
		-Exige disponer de una herramienta adecuada
		-Debe ser un sistema con el que se pueda experimentar
		-Debe desarrollarse rapidamente
		-Equipo de desarrollo reducido


Este modelo es util cuando la definicion de los requisitos es ambigua e imprecisa, porque permite el refinamiento, osea se pueden ampliar los requisitos y las especificacionse derivadas de la etapa anterior.
Uno de los problemas que se puede presentar es la deteccion tardia de requisitos, siendo su correccion tan costosa como en el caso de cascada.

*** Paradigma en Espiral ***

Este paradigma fue desarrollado usando las mejores caracteristicas tanto del ciclo de vida clasico(cascada), como el de la creacion de prototipos, añadiendo un nuevo elemento: "el analisis de riesgo".
El paradigma representado mediante una espiral define 4 actividades principales:
	-Planificacion. Determinacion de objetivos, alternativas y restricciones
	-Analisis de riesgo. Analisis de alternativas e identificacion de riesgos
	-Ingenieria. Desarrollo  del producto del siguiente nivel
	-Evaluacion del Cliente. Valoracion de los resultadoe de la ingenieria

Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:

	Caracteristicas:

		-Se construyen versiones del software cada vez mas complejas
		-Se eligen multiples alternativas y se escoge la mejor
		-La aplicacion se hace por fases
		-Se hace una implementacion parcial y se prueba
		-Despues de cada vuelta se realiza un prototipo

	Factores de Decision
		-Se utiliza cuando los requerimientos no se tienen claros
		-Es menos arriesgado un sistema pequeño que uno grande
		-Los errores producidos en un incremento son solucionados para el proximo incremento

Algunos rasgos distintivos de este modelo son 
	-El reconocimiento explicito de las diferentes alternativas
	-Identificacion de riesgos para cada alternativa desde el comienzo
	-Al dividir el proyecto en ciclos, al final de cada uno existe un acuerdo para los cambios que hay que realizar al sistema
	-El modelo se adapta a cualquier tipo de actividad adicional


***PARADIGMA DE DESARROLLO ADAPTATIVO O AGILE***

En años recientes, se han publicado diversas ideas en cuanto a formas de hacer el proceso de desarrollo de software mas ligero, agil de implementar y  con mejor respuesta a las necesidades del cliente.
Las siguientes metodologias han demostrado beneficios e terminos de "time to market", adaptabilidad a la evolucion de los requisitos, satisfaccion del cliente y entrega de productos rapidamente.

***eXtreme Programming(XP)

La principal diferencia con las metodologias tradicionales es que pone mas enfasis en la adaptabilidad que en la previsibilidad. La capacidad de adaptacion a los cambios de requisitos en cualquier punto del proyecto, experimentalmente demuestra ser una aproximacion mejor y mas realista que intentar definir todos los requisitos al comienzo del proyecto e invertir esfuerzos despues en controlar los cambios en los requisitos.

Los principios originales de la programacion extrema son: 
	Simplicidad
		La simplicidad es la base de XP, se simplifica el diseño para agilizar el desarrollo y facilitar el mantenimiento. Para mantener la simplicidad es necesaria la refactorizacion del codigo, esto para mantenerlo simple a medida que crece. Tambien se aplica la simplicidad en la documentacion, de esta manera el codigo debe comentarse en su justa medida, intentando que el codigo este autodocumentado, para ello se deben eleggir adecuadamente los nombres de las variables, metodos y clases.
		Aplicando la simplicidad junto con la autoria colectiva del codigo y la programacion por parejas se asegura que mientras mas grande se haga el proyecto, todo el equipo conocera mas y mejor el sistema completo.

 	Comunicacion
 		La comunicacion se realiza de diferentes formas. Para los programadores el codigo comunica mejor mientras mas simple seas, si el codigo es complejo hay que hacerlo inteligible.
 		El codigo autodocumentado es mas fiable que los comentarios ya que estos pronto quedan desfasados con el codigo a medida que es modificado.Debe comentarse solo aquello que no va a variar, por ejemplo el objetivo de una clase o la funcionalidad de un metodo.
 		En XP los programadores de comunican constantemente gracias a la programacion en parejas, la comunicacion con el cliente es fluida ya que el cliente forma parte del equipo de desarrollo.El cliente decide que caracteristicas tienen prioridad y siempre debe estar disponible para solucionar dudas.

 	Retroalimentacion
 		Al estar el cliente integrado, su opinion acerca del estado del proyecto se conoce en tiempo real y al realizarse ciclos muy cortos tras los cuales se muestran resultados, se minimiza el tenere que rehacer partes que no cumplen con los requisitos y ayuda a centrarse en lo que es mas importante.
 		Considerando los problemas de tenerr ciclos muy largos, meses de trabajo pueden descartarse debido a cambios en los criterios del cliente o malentendidos por parte del equipo de desarrollo.  El codifo tambien es una fuente de retroalimentacion, por ejemplo a travez de las pruebas unitarias se puede saber el estado del codigo.

 	 Coraje 
 		¿Por que coraje? Para los gerentes la programacion en parejas puede ser dificil de aceptar, parece como si la productividad se fuese a reducir a la mitad, ya que solo la mitad de los programadores estan escribiendo codigo. Entonces hay que tener coraje para confiar en que la programacion por parejas beneficia la calidad del codigo sin repercutir negativamete en la productividad.
 		La simplicidad es uno de los principios mas dificiles de adoptar. Se requiere coraje para implementar las caracteristicas que el cliente quiere ahora sin optar por un enfoque mas flexible que permita futuras modificaciones.

 	 Respeto
 	 	Los mienbros del equipo se respetan unos a otros, los programadores no pueden realizar cambios que hagan que las pruebas existentes fallen o que demore el trabajo de sus compañeros. Los miembros se respetan su trabajo porque siempre estan luchando por la alta calidad en el producto y buscando el diseño mas optimo para la solucion a traves de la refactorizacion del codigo.


 	El exito de XP radica en que enfatiza la implicacion del cliente final y el trabajo en equipo. Es el resultado de las adopcion de las mejores metodologias de desarrollo de acuerdo a lo que se pretende llevar a cabo con el proyecto y aplicarlo de manera dinamica durante el ciclo de vida del software.

Las caracteristicas que identifican este paradigma y sus elementos claves que nos permitan tomar una decision acertada segun el tipo de proyecto son:

 	Caracteristicas
 		-Pruebas unitarias continuas, frecuentemente repetidas y automatizadas, incluyendo pruebas de regresion.
 		-Desarrollo iterativo e incremental,  pequeñas mejoras una tras otra.
 		-Integracion del equipo de programacion con el cliente o usuario.
 		-Correccion de todos los errores antes de añadir nueva funcionalidad.
 		-Mas facil detectar errores
 		-Simplicidad de codigo

 	Factores de Decision
 		-Programacion en parejas, se recomienda que las tareas de desarrollo se lleven a cabo por dos personas en un mismo puesto.
 		-Se recomienda que un representante del cliente trabaje junto al equipo de desarrollo.
 		-La simplicidad y la comunicacion son extraordinariamente complementarias, con mas comunicacion resulta mas facil identificar que se debe y que no se debe hacer

 ***SCRUM***

 Define un marco para la gestion de proyectos, que se ha utilizado con exito durante los ultimos 10 años. Esta especialmente indicada para proyectos con un rapido cambio de requisitos.
 Sus principales caracteristicas son:
 	-El desarrollo se realiza mediante iteraciones, denominadas sprints, con una duracion de variable (normalmente 30 dias).El resultado de cada sprint es un incremento ejecutable que se muestra al cliente
 	-Resuniones a lo largo del proyecto, estas son de verdadera importancia, especialmente la reunion diaria de 15 minutos del equipo de desarrollo para coordinacion en integracion.

SCRUM	es un modelo de referencia que define un conjunto de practicas y roles y que pueden tomarse como punto de partida para definir el proceso de desarrollo que se ejecutara durante el proyecto.
Los roles principales en SCRUM son el "ScrumMaster" que mantiene los procesos y trabaja de manera similar al director del proyecto, el "ProductOwner", que representa a los "stakeholders" (clientes externos o internos), y el Team que incluye a los desarrolladores.
Scrum es un proceso en el que se aplican de manera regular un conjunto de buenas practicas para trabajar en equipo y obtener el mejor resultado posible de un proyecto.
En SCRUM se realizan entregas parciales y regulares del resultado final del proyecto, priorizadas por el beneficio que aportan al receptor del proyecto, por ello SCRUM esta especialmente indicado para proyectos en entornos complejos, donde se necesita obtener resultados pronto, donde los requisitos son cambiantes o poco definidos, donde la innovacion, la competitividad y la productividad son fundamentales.
SCRUM tambien se utiliza para resolver situaciones en que no se esta entregando al cliente lo que necesita, cuando las entregas se alargan demasiado, los costes se disparan o la calidad no es aceptable, cuando se necesita capacidad de reaccion ante la competencia, cuando es necesario identificar y solucionar ineficiencias sistemanticamente o cuando se quiere trabajar utilizando un proceso especializado en el desarrollo del producto.

En SCRUM se ejecutan bloques temporales cortos y fijos (iteraciones de 2 semanas o un mes naturales). Cada iteracion tiene que proporcionar un resultado completo, un incremento de producto final que pueda ser entregado con un minimo esfuerzo cuando el cliente lo solicite.

El proceso parte de la lista de  objetivos/requisitos priorizada del producto, que actua como plan del proyecto. En esta lista el cliente prioriza los objetivos balanceando el valor que le aportan respecto a su coste y quedan repartidos en iteraciones y entregas.
De manera regular el cliente puede maximizar la utilidad de que se desarrolla y el retorno de inversion mediante la replanificacion de objetivos que se realiza al inicio de cada iteracion.

Las actividades que se llevan a cabo en SCRUM son las siguientes:

A)Planificacion de la iteracion.
	El primer dia de la iteracion de realiza una reunion de planificacion de la iteracion, esta tiene 2 partes:
		-Seleccion de los requisitos. El cliente presenta al equipo la lista de requisitos priorizada del producto o proyecto, el equipo pregunta al cliente las dudas que surgen y selecciona los requisitos mas prioritarios que se compromete a completar en la iteracion.
		-Planificacion  de la iteracion. El equipo elabora la lista de tareas necesarias para desarrollar los requisitos. La estimacion de esfuerzo se hace de manera conjunta y los miembros del equipo se autoasignan las tareas.

B) Ejecucion de la iteracion.
	Cada dia el equipo realiza una reunion de sincronizacion(15 minutos maximo). Cada miembro del equipo inspecciona el trabajo que el resto esta realizando (dependencias entre tareas, progreso hacia el objetivo de la iteracion, obstaculos que pueden impedir este objetivo) para poder hacer las adaptaciones necesarias que permitan cumplir con el compromiso adquirido. En la reunion cada miembro del equipo responde a 3 preguntas:
		-¿Que he hecho desde la ultima reunion de sincronizacion?
		-¿Que voy a hacer a partir de este momento?
		-¿Que impedimentos tengo o voy a tener?
	Durante la iteracion el facilitador de encarga de que el equipo pueda cumplir con su compromiso y de que no se merme su productividad
		-Elimina los obstaculos que el equipo no puede resolver por si mismo
		-Protege al equipo de interrupciones externas que puedan afectar su compromiso o productividad.

C) Inspeccion y adaptacion.
	El ultimo dia de la iteracion se realiza la reunion de revision de la iteracion, esta tiene 2 partes:
		-Demostracion (4 hrs maximo). El equipo presenta al cliente los requisitos completados en la iteracion. En funcion de los resultados mostrado el cliente realiza las adaptaciones necesarias (desde la primera iteracion) replanificando el proyecto.
		-Retrospectiva (4 hrs maximo). El equipo analiza como ha sido su manera de trabajar y cuales son los problemas que podrian impedirle progresar adecuadamente, mejorando de manera continua su productividad. El facilitador se encargara de ir eliminando los obstaculos identificados.

Durante cada sprint, un periodo entre 15 y 30 dias, el equipo crea un incremento de software potencialmente entregable. El conjunto de caracteristicas que forman parte de cada sprint vienen del "Product BackLog", que es un conjunto de requisitos de alto nivel priorizados que definen el trabajo a realizar.






